\documentclass[parskip=half]{scrartcl}

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[UKenglish]{babel}
\usepackage{listings}
\usepackage{lstautogobble}
\usepackage{hyperref}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{todonotes}
\usepackage{supertabular,booktabs}

\usepackage{tikz}
\usetikzlibrary{arrows,automata,positioning}


\lstMakeShortInline[]|

\lstset{
    keywords={const,mutable,owned,unowned,linear,value,struct,var,weak,assert}
}

\author{Julian Andres Klode}
\title{TrieHash}
\subtitle{A (very fast) minimal order-preserving perfect hash function}
\date{\today}


\begin{document}
    \maketitle{}
    \begin{abstract}
        Hash functions are used in performance critical places. Common perfect
        hash functions are slow. This paper introduces TrieHash, a tool that generates
        C code that acts as a minimal order-preserving perfect hash function
        for a set of words.
    \end{abstract}
    \section{Introduction}
    Hashing strings to a set of integers is often needed in order to implement
    data structures like hash tables or to generally improve the performance of
    data comparisons.

    A normal hash function takes an ordered set of bytes (a `string') and returns an
    integer, usually in the range of some integer type (that is, 8, 16, 32,
    or 64 bit). Multiple strings may hash to the same value - therefore,
    comparing the hashes of two values is not sufficient to determine if the
    two values are equivalent.

    Another category of hash functions are \textit{perfect} hash functions.
    A perfect hash function maps a fixed-size set of input strings to a
    fixed-size set of results, and unknown inputs to one specific result.

    A perfect hash function is said to be \textit{minimal} if the set of
    results is consecutive.

    A perfect hash function is said to be \textit{order-preserving}
    if given an ordered set of strings to recognise, the outputs matching them
    are ordered in the same way.

    TrieHash is an algorithm, based on tries, to convert a set of input strings
    into a (C) program that functions as a perfect hash function - optionally minimal \textbf{and}
    order-preserving - that maps strings to an enumeration.

    It was created as a reference project to understand what perfect hash
    functions are and how they work. After comparing the performance against
    non-perfect hash functions and hash functions generated by gperf, it
    became evident however, that the performance of TrieHash hash functions
    can match or far exceed the performance of those, and it was considered
    a viable project to maintain. It has been adopted in APT 1.4 for hashing
    of the field names in Debian Packages files.
    
    \section{Related Work}
    GPerf\cite{schmidt2000gperf} is a popular generator for perfect hash
    functions from a set of words. For $n$ words, GPerf generates a lookup
    table mapping keywords into the range $0\ldots k-1$ where $k \ge n$. This
    lookup has false positives: Other words are recognized as well, so gperf
    then performs a comparison of the entire string to see if it actually maps
    the keyword. For case-insensitive operations, this is expensive: The case
    normalization needed for such a comparison is quite inefficient on the
    normal ANSI alphabet. TrieHash in contrast can produce more efficient
    comparisons by simple OR instructions, as shown later.

    trie-gen from gnulib generates tries from a set of words. It stores
    the tries in the data segments of the programs, rather than the code
    segments.

    RE2C\cite{bumbulis1993re2c} can convert regular grammars into C
    programs. It works by generating a DFA for the given grammar and
    then translating that DFA into C code.

    It can essentially be used similarly to TrieHash, but requires a input
    to be terminated by a NUL byte. As shown in section ~\ref{eval}, it is
    otherwise competitive with TrieHash for the test set of words.

    As an example, re2c is used by PHP for lexing the language keywords.
    
    
    \section{Implementation}
    Basically: Given a set of strings, TrieHash inserts them into a trie
    (hence the name). It then traverses the trie, converting each level
    of it to a switch statement. This was the initial approach, but it
    required checking the size of the input at each switch statement,
    exiting the function when the end was reached.

    For example, the words "ab" and "aa" can be converted to the code shown
    in Listing~\ref{lst:initial}. This listing already incorporates some slight
    improvements from later triehash versions: Namely, breaks are only inserted
    between cases, and all switches fall through in the final case to the
    unknown return.

    \begin{lstlisting}[language=C,gobble=8,label=lst:initial,caption=Code generated by initial triehash version,frame=tb]
        Word TrieHashExample(const char *input, size_t len) {
            switch(len > 0 ? input[0] : 0) {
                case 'a':
                    switch (len > 1 ? input[1] : 0) {
                        case 'a':
                            switch(len > 2 ? input[2] : 0) {
                                case 0: return WORD_AA;
                            }
                            break;
                        case 'b':
                            switch(len > 2 ? input[2] : 0) {
                                case 0: return WORD_AB;
                            }
                    }
            }
            return WORD_UNKNOWN;
        }
    \end{lstlisting}

    The second evolution stage was length-indexed TrieHash. Here, the words
    are inserted into multiple tries, one for each word length. Then each of
    these tries is converted into recursive switch statements as before, but
    without any length checks, effectively creating functions recognizing the
    words as prefixes. These per-length functions are then called by a function
    that first switches on the size. This removes the need for a size comparison
    at each byte of the input, and also allows us to reject words of unknown
    length outright without even having to compare their data. An example of
    generated code for the words `aa' and `ab' is given in Listing~\ref{lst:length-indexed}.

    \begin{lstlisting}[language=C,gobble=8,label=lst:length-indexed,caption=Length-Indexed TrieHash,frame=tb]
        static Word TrieHashExample2(const char *input)
        {
            switch(input[0]) {
            case 'a':
                switch (input[1]) {
                case 'a':
                    return WORD_AA;
                case 'b':
                    return WORD_AB;
                }
            }
            return WORD_UNKNOWN;
        }

        Word TrieHashExample(const char *input, size_t len)
        {
            switch(len) {
            case 2:
                return TrieHashExample2(input);
            default:
                return WORD_UNKNOWN;
            }
        }
    \end{lstlisting}

    We also introduced a minor optimization: For ASCII inputs, case insensitive
    operations are performed by performing an OR of the character with \textit{0x20},
    that is by setting the bit that indicates uppercase - as long as that is
    safe to do. The alternative would have been to generate two case statements
    for each character, which would need twice the comparisons in the worst
    case in the generated machine code. An example can be seen in Listing~\ref{lst:ascii}.

        \begin{lstlisting}[language=C,gobble=8,label=lst:ascii,caption=Case-Insensitive Length-Indexed TrieHash,frame=tb]
        static Word TrieHashExample2(const char *input)
        {
            switch(input[0] | 0x20) {
            case 'a':
                switch (input[1] | 0x20) {
                case 'a':
                    return WORD_AA;
                case 'b':
                    return WORD_AB;
                }
            }
            return WORD_UNKNOWN;
        }

        Word TrieHashExample(const char *input, size_t len)
        {
            switch(len) {
            case 2:
                return TrieHashExample2(input);
            default:
                return WORD_UNKNOWN;
            }
        }
    \end{lstlisting}


    The final stage of evolution involves parsing multiple bytes at once: This
    involves the creation of a Trie structure that has decreasing block lengths:
    For example, a word of the length 13 would be indexed by 8 bytes first, then
    4 bytes, then 1 byte. Once that is done, we must ensure that our case sensitivity
    optimisation still works. We do this by rebuilding the trie: At each level
    we split the words at the lowest index at which a character exists in any
    of the keys at that level that may not be optimized. We then rebuild the
    subtries, prepending the tail of the keys that we ignored when rebuilding
    the current level to their keys.

    
    
    \section{Evaluation}
Performance was evaluated against other hash functions. As an input set,
the fields of Debian Packages and Sources files was used, and each hash
function was run 1,000,000 times for each word. The byte count of the
words were then summed up and divided by the total number of nanoseconds
each function ran, giving bytes per nanosecond, AKA gigabyte per second.

It turned out that TrieHash performs just as well or better than the function
generated by gperf (up to 3 times as fast), especially when comparing the performance
of case-insensitive functions. It is also faster than the commonly used djb hash
function, although that one can be optimized further than shown by unrolling
the loops. It is also faster than the hash function APT previously used for
hashing keys in its RFC-822-style files.

It also performs roughly the same as a lexer generated for the same set of
words by re2c, except in case-insensitive operations, where it outperforms
re2c due to the ASCII optimization.

In summary, TrieHash fairs well against its competition on the given input
set. No performance evaluation has been made on other inputs yet, it would
be interesting to see how TrieHash performs on those.



    \bibliographystyle{plain}
    \bibliography{triehash}

\clearpage
\appendix{}
\section{Benchmark data}
\begin{table}[h]
\begin{tabular}{@{}llllllllllll@{}}
\toprule
\begin{minipage}[b]{0.12\columnwidth}\raggedright\strut
function\\/arch\strut
\end{minipage} & \begin{minipage}[b]{0.05\columnwidth}\raggedright\strut
Trie\strut
\end{minipage} & \begin{minipage}[b]{0.05\columnwidth}\raggedright\strut
Trie (*)\strut
\end{minipage} & \begin{minipage}[b]{0.05\columnwidth}\raggedright\strut
re2c\strut
\end{minipage} & \begin{minipage}[b]{0.05\columnwidth}\raggedright\strut
re2c (*)\strut
\end{minipage} & \begin{minipage}[b]{0.05\columnwidth}\raggedright\strut
gperf (*)\strut
\end{minipage} & \begin{minipage}[b]{0.05\columnwidth}\raggedright\strut
gperf\strut
\end{minipage} & \begin{minipage}[b]{0.05\columnwidth}\raggedright\strut
djb (*)\strut
\end{minipage} & \begin{minipage}[b]{0.05\columnwidth}\raggedright\strut
djb (**)\strut
\end{minipage} & \begin{minipage}[b]{0.05\columnwidth}\raggedright\strut
djb\strut
\end{minipage} & \begin{minipage}[b]{0.05\columnwidth}\raggedright\strut
apt (*)\strut
\end{minipage} & \begin{minipage}[b]{0.05\columnwidth}\raggedright\strut
apt (**)\strut
\end{minipage}\tabularnewline
\midrule
\begin{minipage}[t]{0.12\columnwidth}\raggedright\strut
jak-x230 (amd64)\strut
\end{minipage} & \begin{minipage}[t]{0.05\columnwidth}\raggedright\strut
2.4\strut
\end{minipage} & \begin{minipage}[t]{0.05\columnwidth}\raggedright\strut
2.2\strut
\end{minipage} & \begin{minipage}[t]{0.05\columnwidth}\raggedright\strut
1.7\strut
\end{minipage} & \begin{minipage}[t]{0.05\columnwidth}\raggedright\strut
1.2\strut
\end{minipage} & \begin{minipage}[t]{0.05\columnwidth}\raggedright\strut
0.7\strut
\end{minipage} & \begin{minipage}[t]{0.05\columnwidth}\raggedright\strut
1.3\strut
\end{minipage} & \begin{minipage}[t]{0.05\columnwidth}\raggedright\strut
0.7\strut
\end{minipage} & \begin{minipage}[t]{0.05\columnwidth}\raggedright\strut
1.0\strut
\end{minipage} & \begin{minipage}[t]{0.05\columnwidth}\raggedright\strut
0.9\strut
\end{minipage} & \begin{minipage}[t]{0.05\columnwidth}\raggedright\strut
1.2\strut
\end{minipage} & \begin{minipage}[t]{0.05\columnwidth}\raggedright\strut
2.3\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.12\columnwidth}\raggedright\strut
backup (amd64)\strut
\end{minipage} & \begin{minipage}[t]{0.05\columnwidth}\raggedright\strut
1.9\strut
\end{minipage} & \begin{minipage}[t]{0.05\columnwidth}\raggedright\strut
1.7\strut
\end{minipage} & \begin{minipage}[t]{0.05\columnwidth}\raggedright\strut
1.3\strut
\end{minipage} & \begin{minipage}[t]{0.05\columnwidth}\raggedright\strut
0.9\strut
\end{minipage} & \begin{minipage}[t]{0.05\columnwidth}\raggedright\strut
0.5\strut
\end{minipage} & \begin{minipage}[t]{0.05\columnwidth}\raggedright\strut
0.9\strut
\end{minipage} & \begin{minipage}[t]{0.05\columnwidth}\raggedright\strut
0.5\strut
\end{minipage} & \begin{minipage}[t]{0.05\columnwidth}\raggedright\strut
0.7\strut
\end{minipage} & \begin{minipage}[t]{0.05\columnwidth}\raggedright\strut
0.7\strut
\end{minipage} & \begin{minipage}[t]{0.05\columnwidth}\raggedright\strut
0.9\strut
\end{minipage} & \begin{minipage}[t]{0.05\columnwidth}\raggedright\strut
1.7\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.12\columnwidth}\raggedright\strut
asachi.d.o (arm64)\strut
\end{minipage} & \begin{minipage}[t]{0.05\columnwidth}\raggedright\strut
1.2\strut
\end{minipage} & \begin{minipage}[t]{0.05\columnwidth}\raggedright\strut
0.8\strut
\end{minipage} & \begin{minipage}[t]{0.05\columnwidth}\raggedright\strut
0.9\strut
\end{minipage} & \begin{minipage}[t]{0.05\columnwidth}\raggedright\strut
0.6\strut
\end{minipage} & \begin{minipage}[t]{0.05\columnwidth}\raggedright\strut
0.2\strut
\end{minipage} & \begin{minipage}[t]{0.05\columnwidth}\raggedright\strut
0.3\strut
\end{minipage} & \begin{minipage}[t]{0.05\columnwidth}\raggedright\strut
0.3\strut
\end{minipage} & \begin{minipage}[t]{0.05\columnwidth}\raggedright\strut
0.4\strut
\end{minipage} & \begin{minipage}[t]{0.05\columnwidth}\raggedright\strut
0.5\strut
\end{minipage} & \begin{minipage}[t]{0.05\columnwidth}\raggedright\strut
0.7\strut
\end{minipage} & \begin{minipage}[t]{0.05\columnwidth}\raggedright\strut
0.7\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.12\columnwidth}\raggedright\strut
asachi.d.o (armel)\strut
\end{minipage} & \begin{minipage}[t]{0.05\columnwidth}\raggedright\strut
0.9\strut
\end{minipage} & \begin{minipage}[t]{0.05\columnwidth}\raggedright\strut
0.7\strut
\end{minipage} & \begin{minipage}[t]{0.05\columnwidth}\raggedright\strut
0.9\strut
\end{minipage} & \begin{minipage}[t]{0.05\columnwidth}\raggedright\strut
0.6\strut
\end{minipage} & \begin{minipage}[t]{0.05\columnwidth}\raggedright\strut
0.2\strut
\end{minipage} & \begin{minipage}[t]{0.05\columnwidth}\raggedright\strut
0.3\strut
\end{minipage} & \begin{minipage}[t]{0.05\columnwidth}\raggedright\strut
0.3\strut
\end{minipage} & \begin{minipage}[t]{0.05\columnwidth}\raggedright\strut
0.5\strut
\end{minipage} & \begin{minipage}[t]{0.05\columnwidth}\raggedright\strut
0.5\strut
\end{minipage} & \begin{minipage}[t]{0.05\columnwidth}\raggedright\strut
0.7\strut
\end{minipage} & \begin{minipage}[t]{0.05\columnwidth}\raggedright\strut
0.9\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.12\columnwidth}\raggedright\strut
asachi.d.o (armhf)\strut
\end{minipage} & \begin{minipage}[t]{0.05\columnwidth}\raggedright\strut
0.8\strut
\end{minipage} & \begin{minipage}[t]{0.05\columnwidth}\raggedright\strut
0.7\strut
\end{minipage} & \begin{minipage}[t]{0.05\columnwidth}\raggedright\strut
0.7\strut
\end{minipage} & \begin{minipage}[t]{0.05\columnwidth}\raggedright\strut
0.5\strut
\end{minipage} & \begin{minipage}[t]{0.05\columnwidth}\raggedright\strut
0.2\strut
\end{minipage} & \begin{minipage}[t]{0.05\columnwidth}\raggedright\strut
0.2\strut
\end{minipage} & \begin{minipage}[t]{0.05\columnwidth}\raggedright\strut
0.3\strut
\end{minipage} & \begin{minipage}[t]{0.05\columnwidth}\raggedright\strut
0.5\strut
\end{minipage} & \begin{minipage}[t]{0.05\columnwidth}\raggedright\strut
0.5\strut
\end{minipage} & \begin{minipage}[t]{0.05\columnwidth}\raggedright\strut
0.7\strut
\end{minipage} & \begin{minipage}[t]{0.05\columnwidth}\raggedright\strut
0.8\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.12\columnwidth}\raggedright\strut
plummer.d.o (ppc64el)\strut
\end{minipage} & \begin{minipage}[t]{0.05\columnwidth}\raggedright\strut
2.0\strut
\end{minipage} & \begin{minipage}[t]{0.05\columnwidth}\raggedright\strut
1.8\strut
\end{minipage} & \begin{minipage}[t]{0.05\columnwidth}\raggedright\strut
1.6\strut
\end{minipage} & \begin{minipage}[t]{0.05\columnwidth}\raggedright\strut
1.1\strut
\end{minipage} & \begin{minipage}[t]{0.05\columnwidth}\raggedright\strut
0.5\strut
\end{minipage} & \begin{minipage}[t]{0.05\columnwidth}\raggedright\strut
0.4\strut
\end{minipage} & \begin{minipage}[t]{0.05\columnwidth}\raggedright\strut
0.5\strut
\end{minipage} & \begin{minipage}[t]{0.05\columnwidth}\raggedright\strut
0.6\strut
\end{minipage} & \begin{minipage}[t]{0.05\columnwidth}\raggedright\strut
0.7\strut
\end{minipage} & \begin{minipage}[t]{0.05\columnwidth}\raggedright\strut
1.1\strut
\end{minipage} & \begin{minipage}[t]{0.05\columnwidth}\raggedright\strut
1.9\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.12\columnwidth}\raggedright\strut
eller.d.o (mipsel)\strut
\end{minipage} & \begin{minipage}[t]{0.05\columnwidth}\raggedright\strut
0.2\strut
\end{minipage} & \begin{minipage}[t]{0.05\columnwidth}\raggedright\strut
0.2\strut
\end{minipage} & \begin{minipage}[t]{0.05\columnwidth}\raggedright\strut
0.2\strut
\end{minipage} & \begin{minipage}[t]{0.05\columnwidth}\raggedright\strut
0.1\strut
\end{minipage} & \begin{minipage}[t]{0.05\columnwidth}\raggedright\strut
0.1\strut
\end{minipage} & \begin{minipage}[t]{0.05\columnwidth}\raggedright\strut
0.1\strut
\end{minipage} & \begin{minipage}[t]{0.05\columnwidth}\raggedright\strut
0.1\strut
\end{minipage} & \begin{minipage}[t]{0.05\columnwidth}\raggedright\strut
0.2\strut
\end{minipage} & \begin{minipage}[t]{0.05\columnwidth}\raggedright\strut
0.2\strut
\end{minipage} & \begin{minipage}[t]{0.05\columnwidth}\raggedright\strut
0.2\strut
\end{minipage} & \begin{minipage}[t]{0.05\columnwidth}\raggedright\strut
0.2\strut
\end{minipage}\tabularnewline
\bottomrule
\end{tabular}
\caption{Performance results in bytes per ns}

\end{table}

Legend:

\begin{itemize}
\item
  The (*) variants are case-insensitive, (**) are more optimised
  versions of the (*) versions.
\item
  DJB (*) is a DJB Hash with naive lowercase conversion, DJB (**) just
  ORs one bit into each value to get alphabetical characters to be
  lowercase
\item
  APT (*) is the AlphaHash function from APT which hashes the last 8
  bytes in a word in a case-insensitive manner. APT (**) is the same
  function unrolled.
\item
  All hosts except the x230 are Debian porterboxes. The x230 has a Core
  i5-3320M, barriere has an Opteron 23xx.
\end{itemize}
Notes:

\begin{itemize}
\item
  The overhead is larger than needed on some platforms due to gcc
  inserting unneeded zero extend instructions, see:
  https://gcc.gnu.org/bugzilla/show\_bug.cgi?id=77729
\end{itemize}

    
\end{document}
